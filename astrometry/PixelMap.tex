\documentclass[11pt,preprint,flushrt]{aastex}
\def\eqq#1{Equation~(\ref{#1})}
\newcommand{\bfx}{\mbox{\bf x}}
\newcommand{\bfu}{\mbox{\bf u}}
\newcommand{\bfa}{\mbox{\boldmath $\alpha$}}
\begin{document}

\slugcomment{Revised 10 Feb 2013, not up to date yet}

\title{Documentation for PixelMap Classes}

\author{G. M. Bernstein}
\affil{Dept. of Physics \& Astronomy, University of Pennsylvania}
\email{garyb@physics.upenn.edu}

\section{Dependences}
The {\tt PixelMap} classes are placed into the {\tt astrometry} namespace, and make use of the spherical coordinate classes in {\it Astrometry.h}.  As with the {\it Astrometry.h} classes, linear algebra is assigned to Mike Jarvis's {\it TMV} package.  The typedefs in {\it Astrometry.h} and {\it Std.h} provide aliases for the {\it TMV} classes that are used in {\tt PixelMap} classes:  {\tt Vector2} and {\tt Matrix22} are 2-dimensional double-precision vectors/matrices; and {\tt DVector} is an arbitrary-dimension double-precision vector.  A few methods are used from {\tt TMV} that would have to be reproduced if another linear algebra package were to be used.

\section{{\tt PixelMap}}
{\tt PixelMap} is an abstract base clase representing a map from one
2d coordinate space (``pixel'' coords) to another (``world'' coords).
Methods {\tt toWorld()} and {\tt toPix()} execute the forward and inverse maps, respectively.  Methods {\tt  dWorlddPix}  and {\tt dPixdWorld()} return a $2\times2$ matrix giving the partial derivatives of the forward and inverse maps, respectively, and {\tt pixelArea} returns the world-coordinate area of a unit square in pixel space, {\it i.e.} returns the (absolute value of the) Jacobian determinant of the forward map at a specified point.

Each {\tt PixelMap} can depend upon a vector of controlling parameters.  The current values of the parameter vector are accessed with {\tt setParams()} and {\tt getParams()}.  The number of parameters of the map is returned by {\tt nParams()}. 

One can call {\tt toWorldDerivs()}, supplying a reference to a $2\times{\tt nparams()}$ matrix that will be filled with the partial derivatives $\partial[x,y]_{\rm world} / \partial {\bf p}$, where ${\bf p}$ is the parameter vector, evaluated at the supplied values of $[x,y]_{\rm pix}$.  Method {\tt toPixDerivs()} also fills a supplied matrix with the derivatives of the {\em world} coordinates with respect to parameters (even though one is requesting the pixel coordinates).

There are no constraints on the nature of the ``pixel'' and ``world'' coordinate systems, despite the names.  No units are assumed.  The only quality of the pixel space assumed is that an interval $\Delta [x,y]_{\rm pix}=1$ is an appropriate step size for calculating numerical derivatives of the map to world coordinates.  But you also have the option to change this default pixel-space step size with {\tt setPixelStep()} or read it with {\tt getPixelStep()}.  Some implementations may choose to ignore {\tt setPixelStep()} if they have some natural scale in pixel space.

Every {\tt PixelMap} also has a name string that is accessed with {\tt getName()}.  The base class has a default such that if no (or null) {\tt name} string is provided, a name {\tt map\_NN} will be assigned, with a running index number  {\tt NN}.  Most derived classes propagate this naming convention.

Other methods that each {\tt PixelMap} implemenation is expected to have, in order to enable complete serialization and deserialization of these classes:
\begin{itemize}
\item {\tt duplicate()} returns a {\tt PixelMap*} pointing to a deep copy of itself. An exception is that if you have a {\tt SubMap} or {\tt Wcs} that is created with {\tt shareMaps=true,} then the original and the copy both contain only pointers to component {\tt PixelMaps} that they do not own.
\item {\tt write(std::ostream\& os)} serializes all information needed to construct the state of the map (except for the name and the pixel step).
\item {\tt getType()} returns a short string that identifies the implementation being used, e.g. ``{\tt Poly}'' for the {\tt PolyMap} class.
\item {\tt mapType()} is a static member function returning the same class-identifying string as {\tt getType()}.
\item {\tt create(std::istream\& is, string name)} is a static member function that will return a pointer to a freshly constructed instance of the class that has deserialized information from the {\tt write()} routine.  
\end{itemize}

\section{Implementing a new {\tt PixelMap}}
To derive a functioning class from {\tt PixelMap}, the minimial requirement is to implement the two point-mapping methods {\tt toPix()} and {\tt toWorld()}.  A new implementation also requires the {\tt duplicate()} and (de-)serialization routines listed at the end of the previous section.  All other {\tt PixelMap} methods have default implementations in the base class.

It would be common for the forward map {\tt toWorld(double xpix, double ypix, double\& xworld, double\& yworld)} to be defined by some formula for your map.  Sometimes the inverse map is easily expressed analytically, but if not, the base class defines the protected method
\begin{verbatim}
void NewtonInverse(double xworld, double yworld, 
                   double& xpix, double& pix,
                   double worldTolerance) const;
\end{verbatim}
which can be used to solve for the inverse map {\tt toPix()} by using the known forward map {\tt toWorld()} and its derivative.  The solution is done using Newton's iteration: the input values of ${\bf x}_p={\tt (xpix,ypix)}$ is taken as an initial guess of the inverse solution.  The initial guess is mapped to a world point $\hat {\bf x}_w$ using the forward map, and the iteration follows
\begin{equation}
{\bf x}_p \rightarrow {\bf x}_p + \left( \frac{\partial {\bf x}_w}{\partial {\bf x}_p}\right)^{-1} ({\bf x}_w - \hat{\bf x}_w).
\end{equation}
The iteration continues until $|{\bf x}_w - \hat{\bf x}_w|$ is below {\tt worldTolerance} or until more than {\tt PixelMap::NewtonInverse()::maxIterations} is exceeded (this is coded to 10).  Very simple, but unless your starting guess is in a region that is beyond some singularity of the map, it should do well.  {\em Note that it is advantageous to submit a starting {\tt xpix,ypix} that was the solution of a neighboring object.}  An {\tt AstrometryError} is thrown if the Newton iterations do not converge.

The derivative method {\tt dWorlddPix()} is implemented in the base class by a finite-difference estimate using the {\tt getPixelStep()} value as a step size for the simple numerical derivatives.  {\tt dPixdWorld()} is implemented in the base class by taking the matrix inverse of {\tt dWorlddPix()},  and {\tt pixelArea()} is implemented as the determinant of the numerical forward derivatives.

All of the routines related to map parameters are implemented in the base class to have the proper behavior for a map that has {\em no} free parameters.  If your map does have adjustable free parameters, you will have to implement {\tt nParams(), setParams(), getParams(),} and the {\tt toWorldDerivs()} and {\tt toPixDerivs()} that return derivatives with respect to parameters.

\section{Atomic {\tt PixelMap}s}
We call a class derived from {\tt PixelMap} ``atomic'' if it does not result from compounding other {\tt PixelMaps.}  

\subsection{{\tt IdentityMap}}
When you want a map that does nothing.  There are no parameters, and the derivatives of the map are identity matrices.  The serialization of the {\tt IdentityMap} is empty.  {\tt mapType=''Identity''}.

\subsection{{\tt ReprojectionMap}}
This is a {\tt PixelMap} that embodies any map of the celestial sphere from one coordinate system to another that are both represented by a class derived from {\tt SphericalCoords}.  The {\tt ReprojectionMap} is constructed with
\begin{verbatim}
ReprojectionMap(const SphericalCoords& pixCoords,
                const SphericalCoords& worldCoords,
                double scale_=1.,
                string name="");
\end{verbatim}
The ``pix'' and ``world'' coordinate systems are defined by their respective {\tt SphericalCoords} instances.  The {\tt PixelMap} is then defined via
\begin{equation}
\begin{array}{cc}
x_{\rm pix} = {\rm lon}_{\rm pix}/{\tt scale} & y_{\rm pix} = {\rm lat}_{\rm pix}/{\tt scale}  \\
x_{\rm world} = {\rm lon}_{\rm world}/{\tt scale} & y_{\rm world} = {\rm lat}_{\rm world}/{\tt scale} 
\end{array}
\end{equation}
where the (lon,lat) positions mark the same point on the celestial sphere.  

The {\tt ReprojectionMap} class will store duplicates of the two input {\tt SphericalCoord} instances.  Be careful if the input coordinate systems have {\tt shareOrient=true.}  There are no free parameters.

\subsubsection{Example}
Suppose you want a {\tt PixelMap} that treats ecliptic coordinates as the ``pixel'' coordinates and ICRS as the ``world'' system.  And you want the {\tt PixelMap} to work in degree units rather than the radians that are native to the {\tt SphericalCoords} classes.  Here is the code:
\begin{verbatim}
ReprojectionMap map(SphericalEcliptic,
                    SphericalICRS,
                    DEGREE);
double eclipticLon=1.7, eclipticLat=-0.5;  // ecliptic coords in degrees
double icrsRA, icrsDec;     // Want these (in degrees)
// Do a conversion:
map.toWorld(eclipticLon, eclipticLat,
            icrsRA, icrsDec);
\end{verbatim}
There are no free parameters in a {\tt ReprojectionMap}.  Note that it does not matter what coordinates are stored in the initial {\tt SphericalEcliptic} or {\tt SphericalICRS} used in the constructor: all that matters is the coordinate system that they specify.

\subsubsection{Serialized format}
The {\tt mapType} is {\tt ''Reprojection''}.
The serialized {\tt ReprojectionMap} has three lines.  The first two are the serialized pixel and world {\tt SphericalCoords} classes.  The third line has the scaling factor.  The code for (de-)serializing coordinate projections is in {\it astrometry/SerializeProjection.h, .cpp}.  Currently (10 June 2013) the code only knows how to specify ICRS, ecliptic, and gnomonic coordinate systems.  These are simply specified by the words ``ICRS'', ``Ecliptic'', and ``Gnomonic,'' respectively.  The ``Gnomonic'' specification is followed by the RA and Dec of the projection axis and the position angle (in degrees from N through E) of the $y$ axis of the projected system.

\subsection{{\tt PolyMap}}
The {\it PolyMap.h} and {\it PolyMap.cpp} files declare and define polynomial coordinate maps.  They make use of the {\it utilities2/Poly2d.h} classes.  A {\tt PolyMap} is initialized with references to two {\tt Poly2d} instances, defining the two independent functions $x_{\rm world}(x_{\rm pix},y_{\rm pix})$  and $x_{\rm world}(x_{\rm pix},y_{\rm pix})$.  A third construction parameter is a tolerance, specifying how accurate the solutions for inverse mappings must be.  The default value is $0.001/3600$ such that a {\tt toWorld()} call will be accurate to 1 milliarcsecond if the units of the world coordinates are degrees.  The {\tt setWorldTolerance()} method changes this value.

See the {\tt Poly2d} class documentation for instructions on how to define polynomials of desired order.  {\tt PolyMap} makes internal copies of the two {\tt Poly2d} objects at initialization and uses them.  These can be viewed with the {\tt get[XY]Poly()} method and are destroyed with the {\tt PolyMap} object.  The {\tt setToIdentity()} method sets the coefficients to yield the identity transformation.

The parameters of a {\tt PolyMap} object are the coefficients of the two polynomials ($x$ first, then $y$).  The order of coefficients is defined by {\tt Poly2d}.

{\tt PolyMap::toPix()} uses the {\tt PolyMap::NewtonInverse()} method, and {\em always} uses the values of {\tt xpix} and {\tt ypix} on input as initial guesses for the Newton method.

\subsubsection{Serialized Format}
The {\tt mapType} is {\tt ''Poly''}. 
The serialized {\tt PolyMap} has three parts: first come the order and the coefficients of the $x$ polynomial, then those of the $y$ polynomial, then a line containing the world tolerance.  

The format of the polynomials is that of the {\tt Poly2d} class in {\it utilities/Poly2d.h, .cpp.} The first line contains either
\begin{itemize}
\item {\tt Sum }$\langle${\it order}$\rangle$ if the polynomial is constrained to having the sum of $x$ and $y$ orders in a term be $\le${\it order}, or
\item {\tt Each} {\it $\langle$orderX$\rangle\,\langle$orderY$\rangle$}  if a terms are $x^m y^n$ with $m\le${\it orderX} and $n\le${\it orderY.}
\end{itemize}
Following lines contain all the necessary coefficients for the polynomial. {\it utilities/Poly2d.cpp} describes the coefficient order.

\subsection{{\tt LinearMap}}
Also in {\it PolyMap.h} is the class {\tt LinearMap}, with transformation defined by the six-element parameter vector ${\bf p}$ and the formulae:
\begin{eqnarray}
x_{\rm world} & = & p_0 + p_1 x_{\rm pix} + p_2 y_{\rm pix} \\
y_{\rm world} & = & p_3 + p_4 x_{\rm pix} + p_5 y_{\rm pix}.
\end{eqnarray}
The derivatives are all analytic and the {\tt pixelStep} is irrelevant.

\subsubsection{Serialized Format}
The {\tt mapType} is {\tt ''Linear''}.  The {\tt LinearMap} is serialized on two lines, the first giving $p_0, p_1,$ and $p_2$, the second line with $p_3, p_4, p_5.$

\subsection{\tt TemplateMap1d}
The {\it TemplateMap.h} file defines {\tt TemplateMap1d}.  This is a displacement in either $x$ or in $y$ and is determined by a lookup table of displacements plus a scaling factor that is applied to the displacements found in the lookup table.  The scaling factor is the only parameter of the map.  A given {\tt TemplateMap1d} either uses the $x$ coordinate as the lookup and produces $x$ displacements; or uses $y$ coordinates as lookup variable and produces a $y$ displacement.

Displacements are specified on a linearly spaced series of nodes.  The constructor takes {\tt nodeStart} and {\tt nodeStep} arguments specifying the node positions, and a {\tt deviations} vector of displacements (the length of this vector gives the number of nodes).  Values outside the node range use the displacement from the edge node.  Displacements are linearly interpolated between nodes.

\subsubsection{Serialization format}
The {\tt mapType} is {\tt Template1d}. 
The first line of the serialized format is

[{\tt X}$|${\tt Y}] {\it $\langle$no. nodes$\rangle\,\langle$start node$\rangle\,\langle$node step$\rangle$}.

The second line gives the scaling factor to apply to the displacements.

Third and following lines give the displacement values at the nodes.


\section{Composite {\tt PixelMap}s}
The classes in this section satisfy the {\tt PixelMap} interface but wrap one or more other {\tt PixelMap} objects to provide more complex behavior.

\subsection{\tt Wcs}
The {\it Wcs.h} and {\it Wcs.cpp} files declare and define the {\tt Wcs} class, which extends {\tt PixelMap} by including not only a map from pixel coordinates to world coordinates, but also a {\tt SphericalCoords} instance that defines how the world coordinates map to the celestial sphere.  

The {\tt Wcs} constructor takes the following arguments:
\begin{itemize}
\item {\tt PixelMap* pm} is a pointer to the map from pixel to world coordinates.
\item {\tt const SphericalCoords\& nativeCoords} gives the projection in which the world coordinates will be interpreted as lon/lat.  A duplicate of the object is created and stored, and is destroyed with the {\tt Wcs}.
\item {\tt double wScale} is a scaling factor applied to the world coordinates before the projection interprets them as radians.  The default is {\tt DEGREE}, {\it i.e.\/} the world coordinates are in degrees.
\item {\tt bool shareMap}, if {\tt true}, means that a pointer to {\tt pm} will be stored and it will not be destroyed by {\tt ~Wcs}.  Note this means that parameters of the map are also shared. If {\tt shareMap=false} (the default), a duplicate of {\tt pm} is created and owned by this object.
\end{itemize}

\subsubsection{Reprojection and {\tt Wcs} as a {\tt PixelMap}}
The {\tt Wcs} class implements the {\tt PixelMap} interface. In the simplest case, this is just wrapping the {\tt PixelMap} behavior of the {\tt pm} given on construction of the {\tt Wcs}.  However a call to {\tt reprojectTo()} changes this behavior
 by defining a {\em target coordinate system} which may differ from the {\em native} coordinate system.  The {\tt toWorld} transformation implemented by the {\tt Wcs} is then defined as follows:
\begin{enumerate}
\item The input pixel coordinates $(x_{\rm pix},y_{\rm pix})$ are transformed to coordinates $({\it lon},{\it lat})$ by the {\tt PixelMap} that is wrapped by the {\tt Wcs}.
\item The $({\it lon},{\it lat})$ coordinates are mapped to a location ${\bf x}_{\rm sky}$ on the celestial sphere using the native coordinate system supplied at construction of the {\tt Wcs}.
\item The sky location ${\bf x}_{\rm sky}$ is mapped to a new pair of coordinates using the projection specified in a call to {\tt reprojectTo()}.  The coordinates in this projection are rescaled by ${\tt wScale}$ to yield the ``world'' coordinates $(x_w,y_w)$.
\end{enumerate}
In other words, when the {\tt Wcs} is accessed through the {\tt PixelMap} interface, it behaves as the original {\tt pm} map followed by a reprojection from the native coordinate system to a new target coordinate system.  The free parameters of the {\tt Wcs} are the free parameters of {\tt pm}---the coordinate systems are taken as fixed, with no adjustable parameters.

\subsubsection{Methods}
The {\tt Wcs} implements all the methods of the {\tt PixelMap} interface.  In addition there are these methods specific to {\tt Wcs}:
\begin{itemize}
\item {\tt getMap(), getScale(), getNativeCoords()} are accessors to the internal {\tt PixelMap}, the coordinate scaling factor, and the projection to the celestial sphere.
\item {\tt reprojectTo(const SphericalCoords\& targetCoords)} specifies the second coordinate system used to map the sky position back to 2d coordinates.  A duplicate of {\tt targetCoords} is produced and owned by the {\tt Wcs} class.
\item {\tt getTargetCoords()} returns (a pointer to) the current target coordinates, if any (else returns zero).
\item {\tt useNativeProjection()} discards any specified target coordinate system, so that the {\tt PixelMap} interface returns to using world coordinates in the native projection.
\end{itemize}

\subsubsection{Serialized  format}
The {\tt MapType} is {\tt "WCS"}.
The (de-)serialization routines are not yet implemented for {\tt Wcs} (as of 11 June 2013).

\subsection{\tt SubMap}
The {\tt SubMap} is declared in {\it astrometry/PixelMapCollection.h} and defined in {\it astrometry/SubMap.cpp.}
A {\tt SubMap} represents the compounded action of zero or more other {\tt PixelMap}s.  If the action of the $i^{\rm th}$ map from its pixel to its world coordinates is written as $M_i({\bf x}_{\rm pix})$, then the map from pixel to world coordinates for the {\tt SubMap} is $M_{N-1}(\ldots M_1(M_0({\bf x}_{\rm pix}))).$ When constructing a {\tt SubMap} one supplies:
\begin{itemize}
\item {\tt const list<PixelMap*>\& pixelMaps}, a list of (pointers to) the component pixel maps making up the chain.  The component {\tt PixelMap}s can themselves be {\tt SubMap}s or other compound types.
\item {\tt string name}, a name for the new map.
\item {\tt bool shareMaps}, if set to the default {\tt false}, means that duplicates of all the input component {\tt PixelMaps} will be created and owned by the {\tt SubMap} class.  If {\tt shareMaps=true} then pointers to the input instances will be saved, and all parameters will continue to be shared with the input maps.  The {\tt SubMap} destructor deletes the component {\tt PixelMaps} only if {\tt shareMaps=false}.
\end{itemize}

\subsubsection{{\tt SubMap} as a {\tt PixelMap}}
The coordinate mapping methods of {\tt PixelMap} are implemented as expected for chained functions.  Note when there are zero maps in the {\tt SubMap} it behaves as the {\tt IdentityMap}.  The {\tt getPixelStep(), setPixelStep()} methods access the corresponding routines in the first element of the map chain.

The {\tt nParams(), getParams(), setParams()} methods of {\tt SubMap} work with a parameter vector that is the concatenation of the parameters of all the component maps.  Element 0 of the {\tt SubMap} parameter vector is element 0 (if any) of the first {\tt PixelMap} in the {\tt SubMap} chain.  Getting or setting parameters of the {\tt SubMap} results in the operation being transmitted to all the relevant component {\tt PixelMap}s.

\subsubsection{Interaction with {\tt PixelMapCollection}}
A {\tt SubMap} can be created as a chain of elements held in a {\tt PixelMapCollection}, as discussed in Section~\ref{pmc}.  The {\tt SubMap} is aware of where the parameters of its elements live within a master parameter vector for all the maps in the collection.  In Section~(\ref{pmc}) we also discuss a mechanism whereby some elements of the map chain can be ``frozen'' such that they do not appear in the parameter vectors accessed through the {\tt PixelMap} interface.

\subsubsection{Methods}
The {\tt SubMap} extends the {\tt PixelMap} interface with these methods:
\begin{itemize}
\item {\tt const PixelMap* getMap(int i) const} returns a pointer to the component map $i$.  No range checking is done.
\item {\tt int nMaps() const} returns the number of component maps.
\item {\tt startIndex(int iMap), nSubParams(int iMap)} give the first and number of entries in a global parameter vector corresponding to the parameters from the {\tt iMap}$^{\rm th}$ map in the chain.  For a {\tt SubMap} created by the user, these index the concatenated vector of the {\tt SubMap}'s component maps.  In Section~\ref{pmc} we describe the more complex behavior when a {\tt SubMap} is produced from a {\tt PixelMapCollection}.
\item {\tt int mapNumber(int iMap) const} returns the unique id number of a {\tt SubMap} component in the case that the {\tt SubMap} was issued by a {\tt PixelMapCollection}.  See \ref{pmc}.
\end{itemize}

\subsubsection{Serialized format}
The {\tt MapType} is {\tt "Composite"}.
Attempts to serialize a {\tt SubMap} will throw an exception.  It is intended to be (de-)serialized only as part of a {\tt PixelMapCollection}.

\subsection{CompoundPixelMap}
The {\tt CompoundPixelMap} is a {\bf DEPRECATED} predecessor to {\tt SubMap} for the representation of chains of {\tt PixelMap}s.  We will not document it further here.

\subsection{{\tt TPVMap}}

The FITS WCS standard defines maps from pixel to sky coordinates that can be represented by our {\tt Wcs} class wrapping our {\tt SubMap} class.  The files {\it astrometry/TPVMap.h} and {\it astrometry/TPVMap.cpp} contain functions that allow us to read or write FITS headers that represent the actions of our {\tt Wcs} class.  

In practice we do not (yet) attempt to represent the full range of WCS maps sanctioned by the FITS standards.  We implement only the pseudo-standard {\tt TPV} map used by Emmanuel Bertin's {\it SCAMP} program (also sometimes labeled as a {\tt TAN} map).
These maps follow a proposal for a FITS WCS standard that was never formally adopted, and has some oddities.  But it it widely used.  I have implemented a specific subset of the standard that is used by Emmanuel.

\subsubsection{The FITS standard}
The map from $(x_{\rm pix},y_{\rm pix})$ to celestial coordinates has three parts in the FITS WCS standard:
\begin{enumerate}
\item A linear mapping from pixel coordinates to ``intermediate world coordinates'' $(x_1,y_1)$ defined by
\begin{eqnarray}
x_1 & = & {\tt CD1\_1}(x_{\rm pix}-{\tt CRPIX1}) + {\tt CD1\_2}(y_{\rm pix}-{\tt CRPIX2}) \\
y_1 & = & {\tt CD2\_1}(x_{\rm pix}-{\tt CRPIX1}) + {\tt CD2\_2}(y_{\rm pix}-{\tt CRPIX2}) .
\end{eqnarray}
Quantities in {\tt typewriter font} are FITS keywords.
This map can clearly be implemented as a {\tt LinearMap}.  The output units are defined by {\tt CRUNIT[12]}, which are string-valued FITS fields that are supposed to have the value {\tt 'deg'}.  The {\it TPVMap} code currently assumes this is true, without checking.
\item A polynomial map that transforms the $(x_1,y_1)$ coordinates into the $(\xi,\eta)$ coordinates in a projection of the celestial sphere.  The polynomial definition is as usual:
\begin{eqnarray}
\xi & = & \sum_{ij} a_{ij} x_1^i y_1^j \\
\eta & = & \sum_{ij} b_{ij} x_1^i y_1^j.
\end{eqnarray}
The polynomial coefficients are assigned FITS keywords by a quirky convention:
\begin{equation}
\begin{array}{c|c}
{\tt PV1\_0} = a_{00} & {\tt PV2\_0} = b_{00} \\
{\tt PV1\_1} = a_{10} & {\tt PV2\_1} = b_{01} \\
{\tt PV1\_2} = a_{01} & {\tt PV2\_2} = b_{10} \\
{\tt PV1\_4} = a_{20} & {\tt PV2\_4} = b_{02} \\
{\tt PV1\_5} = a_{11} & {\tt PV2\_5} = b_{11} \\
{\tt PV1\_6} = a_{02} & {\tt PV2\_6} = b_{20} \\
{\tt PV1\_7} = a_{30} & {\tt PV2\_7} = b_{03} \\
{\tt PV1\_8} = a_{21} & {\tt PV2\_8} = b_{12} \\
{\tt PV1\_9} = a_{12} & {\tt PV2\_9} = b_{21} \\
{\tt PV1\_10} = a_{03} & {\tt PV2\_10} = b_{30} \\
{\tt PV1\_12} = a_{40} & {\tt PV2\_12} = b_{04} \\
{\tt PV1\_13} = a_{31} & {\tt PV2\_13} = b_{13} \\
{\tt PV1\_14} = a_{22} & {\tt PV2\_14} = b_{22} \\
{\tt PV1\_15} = a_{13} & {\tt PV2\_14} = b_{31} \\
{\tt PV1\_16} = a_{04} & {\tt PV2\_14} = b_{40}
\end{array}
\end{equation}
Note there are no {\tt PV[12]\_3} or {\tt PV[12]\_11} terms (according to the convention they are meant to be coefficients for radial $r$ and $r^3$ terms, which are not analytic at the origin and hence not useful to us.)  The FITS convention is that any missing coefficient is zero, hence the order of the polynomial is determined by the largest ${\tt PV}x\_y$ that is present in the FITS header.
\item A deprojection from the $(\xi,\eta)$ coordinates onto the celestial sphere.  Many projections are in principle possible and specified by the {\tt CTYPE[12]} keywords, but SCAMP always uses the gnomonic projection that is declared by setting {\tt CTYPE1}$=${\tt RA---TAN} and {\tt CTYPE2}$=${\tt DEC--TAN}, or {\tt RA---TPV} and {\tt DEC--TPV}.  Any other values for these keywords throw an {\tt AstrometryError}.  The projection pole RA and Dec in the ICRS system are given as degree values in the fields {\tt CRVAL1} and {\tt CRVAL2}, respectively.  The gnomonic projection is assumed to have its $\eta$ axis pointing along the north ICRS meridian, {\it i.e.} position angle zero.
\end{enumerate}

\subsubsection{Implementing {\tt TPV} as a {\tt Wcs}}
The FITS {\tt TPV} standard is implemented as a {\tt Wcs} having its {\tt nativeCoords} equal to a {\tt Gnomonic} projection oriented to the ICRS meridian at the projection pole.  The {\tt Wcs} wraps a {\tt SubMap} consisting of a {\tt LinearMap} followed by a {\tt PolyMap}.  
If no {\tt PV} terms are found in the header, the polynomial map is omitted and the linear map is used without it.

We declare three functions that can be used to convert between FITS-standard headers and our {\tt astrometry} classes.
\begin{itemize}
\item {\tt Wcs* readTPV(const img::Header\& h, string name="")} can read a FITS header (in the {\tt img::Header} class), extract all the keywords described above to specify a WCS, and return a pointer to a new {\tt Wcs} object implementing this transformation.  An optional name is assigned to the {\tt Wcs}.  It component {\tt SubMap} has the same name.
\item {\tt img::Header writeTPV(const Wcs\& w)} writes a FITS header meeting the TPV pseudo-standard.  This will throw an exception if the input {\tt Wcs} is not in the form of a {\tt LinearMap} and/or {\tt PolyMap} in sequence.
\item {\tt Wcs* fitTPV} is a function that will fit a TPV-form WCS to approximate the behavior of an arbitrary {\tt Wcs} provided as  input.  The full declaration is
\begin{verbatim}
Wcs* fitTPV(Bounds<double> b,
            const Wcs& wcsIn,
	    const SphericalCoords& tpvPole,
	    string name="",
	    double tolerance=0.0001*ARCSEC/DEGREE);
\end{verbatim}
The polynomial coefficients of the output TPV-format map are solved to minimize the RMS deviation from the {\tt WcsIn} over the rectangular region {\tt b} (see the {\it utilities2/Bounds.h} file for info on this class).   The polynomial order is increased until this RMS deviation is $<{\tt tolerance}$.  There are {\tt startOrder} and {\tt maxOrder} constants defined in {\it TPVMap.cpp}, currently 3 and 5, respectively.  If {\tt maxOrder} is exceeded, an {\tt AstrometryError} is thrown.  Note that the usual convention for FITS WCS systems is to express world coordinates in degrees, so the default {\tt tolerance} is 0.1 milliarcsec.  The output {\tt Wcs} is defined to have its projection be {\tt Gnomonic} about the {\tt tpvPole} position.
\end{itemize}

\section{\tt PixelMapCollection \& SubMap}
\label{pmc}

When reconciling world-coordinate maps for a set of data / reference catalogs, it is typical to have a large number of ``building block'' coordinate maps that are put together in different combinations to maps parts of individual exposures.  {\tt PixelMapCollection} (PMC) is a class that serves as a warehouse for all these building blocks, puts them together into any specified chain to form the complete WCS transformations, and facilitates bookkeeping of the parameters of these building blocks within a global parameter vector during a fitting process.  The {\tt SubMap} can wrap any chain of {\tt PixelMap}s from a PMC and keep track of where their parameters live within the global parameter vector.  The {\tt PixelMapCollection} also controls the creation and destruction, serialization and de-serialization of a full complement of {\tt PixelMap} and {\tt Wcs} components needed to describe a set of image.

\subsection{Concepts}
A PMC consists of the following kinds of objects:
\begin{itemize}
\item {\it Atomic maps:} these are irreducible {\tt PixelMap}s.  Each element of the PMC must have a unique name, by which it is accessed.  The PMC maintains a global parameter vector that is the concatentation of all the parameters of its atomic maps.
\item {\it Chains:} A compounded sequence of atomic maps can be assigned to a named chain.  The name of the chain must not duplicate the name of any other chain or atomic map.  The parameters of a chain are the union of its member atomic maps' parameters.
\item {\it WCSs:} A map (either atomic or chain) associated with a projection of world coordinates back to the sky.  Duplication of WCS names is not allowed, but a WCS can have the same name as an atomic or chain map.
\end{itemize}

The PMC can {\em issue} a pointer to a {\tt SubMap} that wraps any atomic map or chain in the collection---you request this by the name of the map or chain that you want.  You can use this {\tt SubMap} for mapping and fitting coordinates.  The {\tt SubMap} knows where the parameters of its constituent maps live within the PMC's global parameter vector.  The PMC keeps track of all the {\tt SubMap}s it has issued, keeps their parameter indices up to date, and deletes them upon destruction of the PMC.

You can tell the PMC to fix the parameters of any atomic map (or chain of them) to their current values.  These will then no longer appear as free parameters in the {\tt PixelMap} interfaces to the {\tt SubMap}s.  You can later free these parameters.

You can also {\em issue} a pointer to a {\tt Wcs} object that realizes any of the WCS systems that the PMC knows about.  Again, the request is by name, and the PMC keeps track of and deletes all the {\tt Wcs}'s it issues.

In addition to {\em issuing} a realization of any map or WCS, the PMC can {\em clone} them, producing for you a pointer to a new {\tt SubMap} or {\tt Wcs} object.  The difference is that a clone is a fresh deep copy, decoupled from the global parameter vector of the PMC.  Unlike issued objects, these remain valid after the PMC itself is deleted.

At any point the definitions and current parameter values of all these elements can be serialized to a stream.  (Optionally you can serialize only those elements needed to build a particular map or WCS).  

There are multiple ways to add new maps, chains, and WCS's to the PMC.  
The PMC can {\em learn} an existing map, essentially creating and storing its own duplicate that you can access by the name of the original object.  Composite maps ({\it e.g.\/} {\tt SubMaps}) can be learned as well---they define a new chain, and their atomic elements are learned.  The PMC can also learn a WCS by being handed an existing {\tt Wcs} object.  A PMC can also learn the entire contents of another PMC.

Whenever a PMC is learning about some existing object, there is a flag {\tt duplicateNamesAreExceptions} for the operation which determines the action taken if the object to be learned has a name that duplicates a name already in the PMC.
If this flag is {\tt false} (the default), the new object is ignored and we assume that the previous object of the same name can be used in its place.  This is the desired situation when we are for example learning the WCS systems of many exposures that share common distortion maps for a given CCD.  If the flag is {\tt true}, then duplicate names throw exceptions.

A chain can also be {\em defined} by specifying the chain of maps that it is made of.  A new WCS can be defined from giving the name of its coordinate map and supplying a {\tt SphericalCoords} object defining the projection onto the sky.

The third way to enter new maps or WCS's into the PMC is by deserializing from a stream.

\subsection{Methods}
\subsubsection{Building the collection}
The constructor for {\tt PixelMapCollection} creates an empty collection.  The following methods expand the collection (see also the serialization methods below).  Note that all of the {\tt learn} methods take a {\tt duplicateNamesAreExceptions} flag as described above.
\begin{itemize}
\item {\tt learn(PixelMapCollection\& source)}: duplicate the names, characteristics, and current parameters of everything in the {\tt source} collection.
\item {\tt learnMap(const PixelMap\& pm)}: duplicate the name, characteristics, and current parameters of {\tt pm} into this collection.  Note that if {\tt pm} is a {\tt SubMap}, all its component maps are learned as well.  If {\tt pm} is a {\tt Wcs}, it is learned as a new chain including a {\tt ReprojectionMap}, not as a new WCS.
\item {\tt learnWcs(const Wcs\& pm)}: duplicate the name and projection of {\tt wcs} and learn its underlying {\tt PixelMap} as well. 
\item {\tt defineChain(string chainName, const list<string>\& elements)}: Define a new map chain with the given name and compounding the maps named by the strings in {\tt elements}.
\item {\tt defineWcs(string wcsName, const SphericalCoords\& nativeCoords, string mapName,
		   double wScale = DEGREE)}: define a WCS system to be the map described by {\tt mapName} followed by projection to the sky described by the {\tt nativeCoords} system. 
               \end{itemize}

\subsubsection{Extracting collection elements}
These methods produce pointers to {\tt SubMap}s or {\tt Wcs}'s realizing the maps and WCS's known to the collection.  The {\tt issue} methods give pointers to objects maintained by this {\tt PixelMapCollection} and linked to its global parameter vector.  The {\tt clone} methods return pointers to deep copies that are decoupled from this PMC.  All throw exceptions if an unknown name is requested.
\begin{itemize}
\item {\tt SubMap* issueMap(string mapName)}
\item {\tt Wcs* issueWcs(string wcsName)}
\item {\tt PixelMap* cloneMap(string mapName)}
\item {\tt Wcs* cloneWcs(string wcsName)}
\end{itemize}

\subsubsection{Parameter manipulation and bookkeeping}
\begin{itemize}
\item {\tt  void setParams(const DVector\& p)}: set the global parameter vector from {\tt p}.
\item {\tt  DVector getParams()}: return the global parameter vector.
\item {\tt  int nParams():} return the size of the global parameter vector.
\item {\tt void setFixed(list<string> nameList, bool isFixed)}: Declare that the parameters of all the maps with names in {\tt nameList} are to be fixed (freed) if {\tt isFixed=true} ({\tt false}).  If a map's parameters are fixed, then they are removed from the global parameter vector.  Any issued {\tt SubMap}s that refer to this map are updated to indicate appropriately smaller number of free parameters and index reference for all parameters are updated.  If any of the names is of a chain, then all members of the chain have their parameters fixed (or freed).
\item {\tt void setFixed(string name, bool isFixed)}: same as above, just freeing/fixing a single map.
\item {\tt bool getFixed(string name)}: report whether parameters of the map with {\tt name} are free or fixed.  Note the potential for confusion about chains, which can think they are fixed but have had some of their elements freed by other operations.
\item {\tt bool mapExists(string name)}: reports whether there is an atomic map or a chain with this {\tt name}.
\item {\tt bool wcsExists(string name)}: reports whether there is a WCS with this {\tt name}.
\item {\tt int nWcs()}: report number of WCS's known to this collection.
\item {\tt int nMaps()}: report number of maps known to this collection (atomic maps plus defined chains).
\item {\tt int nAtomicMaps()}: report number of atomic maps known to this collection.
\item {\tt int nFreeMaps()}: report number of atomic maps known to this collection that have free parameters.
\end{itemize}

\subsubsection{Serialization}
All of the (de-)serialization of {\tt PixelMaps} and WCS's is intended to be done via the {\tt PixelMapCollection} methods.  {\em The class must be told of the existence of every kind of {\tt PixelMap} that it will encounter in deserialization.}  If you will be deserializing any atomic map type beyond the {\tt Identity, Reprojection, Poly,} and {\tt Linear} maps, you need to put this in your code once.
\begin{verbatim}
PixelMapCollection::registerMapType<PolyMap>()
\end{verbatim}
This templated function has told the {\tt PixelMapCollection} class to look for serialized {\tt PolyMap}s and given it the address of the function for deserializing them.

The methods for (de-)serialization are:
\begin{itemize}
\item {\tt void write(ostream\& os)}: serializes the entire collection to the stream.
\item {\tt writeMap(ostream\& os, string name)}: serialize just the named map and anything it depends upon.
\item {\tt writeWcs(ostream\& os, string name)}: serialize just the named WCS and anything it depends upon.
\item {\tt bool read(istream\& is, string namePrefix="")}: deserialize all the maps and WCS's from the input stream and add them to the collection.  Returns {\tt true} on success, {\tt false} if the stream is not a serialized {\tt PixelMapCollection}, and throws an exception for format errors.
\end{itemize}

\subsubsection{Serialized format}
A serialized {\tt PIxelMapCollection} has the following format.  Any blank line or any line starting with {\tt \#} is ignored as a comment.  
\begin{enumerate}
\item The stream must start with a single line starting with the word {\tt PixelMapCollection}.
\item Each atomic map is specified by this sequence:
\begin{enumerate}
\item A line containing {\it $\langle$mapType$\rangle\,\langle$map name$\rangle\,\langle$pixel Step$\rangle$}.
\item Further lines with the serialized content produced by {\tt PixelMap.write()}.
\end{enumerate}
\item Each chain is specified by this sequence:
\begin{enumerate}
\item A line containing {\tt Composite} {\it $\langle$map name$\rangle$}.
\item Further lines with the names of the elements of the chain, any number per line.
\end{enumerate}
\item Each WCS is specified by this sequence:
\begin{enumerate}
\item A line containing {\tt WCS} {\it $\langle$WCS name$\rangle\,\langle$pixel map name$\rangle$}.
\item A line with the serialized version of the native coordinate system.
\item A line with the coordinate scaling factor {\tt wScale}.
\end{enumerate}
\end{enumerate}

\end{document}
